
class Solution {
public:
typedef pair<int,int>P;
    int minCostConnectPoints(vector<vector<int>>& points) {
        int n=points.size();

        vector<vector<P>>adj(n);
         
         for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                int x1=points[i][0];
                int y1=points[i][1];

                int x2=points[j][0];
                int y2=points[j][1];

                int dist=abs(x1-x2)+abs(y1-y2);

                adj[i].push_back({j,dist});
                adj[j].push_back({i,dist});
            }
         }

         // to get the the path with minimum path weight to connect all the point the we apply mst using prism algorithm
           priority_queue<P,vector<P>,greater<P>>pq;
           pq.push({0,0});

           int sum=0;
           vector<int>vis(n,0);
            // vis[0]=1;
           while(!pq.empty()){
               auto it=pq.top();
               int wt=it.first;
               int node=it.second;
                pq.pop();
               if(vis[node]==1) continue;

               sum+=wt;
               vis[node]=1;
               for(auto p:adj[node]){
                 int newnode=p.first;
                 int newwt=p.second;

                 if(!vis[newnode]){
                    pq.push({newwt,newnode});
                 }
               }
           }
           return sum;
    }
};
